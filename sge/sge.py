import json
import random
from time import time
import warnings
from copy import deepcopy
from operator import itemgetter
from typing import Any, Callable, Dict, List, Tuple, Union

import numpy
from pyclustering.cluster.center_initializer import kmeans_plusplus_initializer
# Funções para clustering utilizando PyClustering
# Importante: para realização do TP é imprescindível que seu PyClustering esteja na versão 0.10.1 ou superior
from pyclustering.cluster.kmeans import kmeans
from pyclustering.utils.metric import distance_metric, type_metric
from sklearn.metrics.cluster import v_measure_score
from sklearn.cluster import AgglomerativeClustering
from scipy.spatial.distance import cdist
from .tree import DistanceCreator


class StructuredGrammarEvolution:
    def __init__(self,
                 array_len: int,
                 population_size=100,
                 mutation_prob=0.3,
                 gene_mutation_prob=0.05,
                 crossover_prob=0.1,
                 k=3,
                 elitism=3,
                 max_levels=2,
                 min_levels=2,
                 generations=100,
                 classes=2,
                 checkpoint=5,
                 checkpoint_prefix=""
                 ) -> None:
        """Initializer for the framework for performing a symbolic regression for a distance between two points
        based on the clustering generated by the distance between them using Strucured Grammar Evolution.

        Args:
            array_len (int): Length of the array representing a point
            population_size (int, optional): Initial population size for performing the evolution. Defaults to 100.
            mutation_prob (float, optional): Probability of mutation on a given individual (codon by codon). Defaults to 0.3.
            crossover_prob (float, optional): Probability of crossover between individuals. Defaults to 0.1.
            k (int, optional): Size of the tourney applied on each generation. Defaults to 3.
            elitism (int, optional): Number of individuals kept between each generation. Defaults to 3.
            max_levels (int, optional): Maximum levels of each branch of the grammar tree. Defaults to 2.
            min_levels (int, optional): Minimum levels of each branch of the grammar tree. Defaults to 2.
            generations (int, optional): Number of generations to be created. Defaults to 100.
            classes (int, optional): Number of classes in the cluster evaluation. Defaults to 2.
            checkpoint (int, optional): Number of generations between each checkpoint. Defaults to 5.
            checkpoint_prefix (str, optional): Prefix of the checkpoint that will be saved. Defaults to "".
        """
        warnings.filterwarnings("ignore")
        self.population_size = population_size
        self.crossover_prob = crossover_prob
        self.k = k
        self.mutation_prob = mutation_prob
        self.elitism = elitism
        self.distance_creator = DistanceCreator(
            array_len, max_levels, min_levels, mutation_prob=gene_mutation_prob)
        self.mutation_prob = mutation_prob
        self.generations = generations
        self.classes = classes
        self.checkpoint = checkpoint
        self.checkpoint_prefix = checkpoint_prefix

    def __call__(self, X, Y) -> float:
        """Applies the best individual to a given set of points

        Args:
            X (df): Set of points to be clustered
            Y (df): Cluster for each point

        Returns:
            float: The v-measure between the original clustering and the one generated by the best individual
        """
        return self._eval(self.best_indivitual, X, Y)

    def initializePopulation(self):
        """Initializes the population with the size informed in instantiation.
        """
        self.population = [self.distance_creator.createIndivitual()
                           for _ in range(self.population_size)]

    def tourney(self) -> Dict[str, Union[str, Dict[str, List[int]], Callable]]:
        """Performs a tourney in the current population of the size k defined in instantiation.
        The tourney gets a sample of size k and returns the individual with the best fitness between them.

        Returns:
            Dict[str, Union[str, Dict[str, List[int]], Callable]]: Winner of the tourney
        """
        individuals = random.sample(self.population, self.k)
        individuals.sort(key=lambda i: i['fitness'], reverse=True)
        return deepcopy(individuals[0])

    def create_generation(self):
        """Applies the operators of mutation, reproduction and crossover of the classic evolutionary programming
        to create a new population from the current one.
        """
        self.population.sort(key=lambda x: x["fitness"], reverse=True)
        new_pop = self.population[:self.elitism]
        better_than_parent = 0
        worse_than_parent = 0
        reproduced = 0
        mutated = 0
        crossed = 0
        while len(new_pop) < self.population_size:
            new_t = self.tourney()
            prev_fitness = new_t["fitness"]

            if random.random() < self.crossover_prob:
                t2 = self.tourney()
                new_t = self.distance_creator.crossover(new_t, t2)
                new_t["fitness"] = None
                new_t["fenotype"] = None
                crossed += 1

            if random.random() < self.mutation_prob:
                new_t["genome"] = self.distance_creator.mutate(new_t["genome"])
                new_t["fitness"] = None
                new_t["fenotype"] = None
                mutated += 1

            if new_t["fitness"] != None:
                reproduced += 1
            else:
                self.evaluate_individual(new_t)
                if new_t["fitness"] > prev_fitness:
                    better_than_parent += 1
                elif new_t["fitness"] < prev_fitness:
                    worse_than_parent += 1

            new_pop.append(new_t)

        self.population = new_pop
        return {
            "reproduced": reproduced,
            "better": better_than_parent,
            "worse": worse_than_parent,
            "mutated": mutated,
            "crossed": crossed,
        }

    def _eval(self, ind, X, Y):
        
        if ind["fenotype"] == None:
            self.distance_creator.expand(ind)

        

        # evaluation using a pre-constructed distance matrix
        # with sklearn's agglomerative clustering algorithm
        # as was allowed in the Duvidas TP1 Moodle thread.
        d_matrix = cdist(X, X, metric=ind["fenotype"])
        d_matrix = numpy.nan_to_num(d_matrix)
        kmeans_instance = AgglomerativeClustering(n_clusters=self.classes,
                                                    affinity="precomputed",
                                                    linkage="single"
                                                    )

        # predicts and adapts the cluster numbers to be compatible with the 
        # numbers given in the test CSV
        pred = kmeans_instance.fit_predict(d_matrix) + numpy.ones(len(X))
        # recupera os clusters gerados

        return v_measure_score(Y, pred)

    def evaluate_individual(self, ind: Dict[str, Union[str, Dict[str, List[int]], Callable]]):
        """Evaluates the fitness of a given individual using the v-measure between the clustering generated from
        the original distance function and the clustering generated from the given individual's distance function.
        Sets both the fenotype and the fitness of the individual

        Args:
            ind (Dict[str, Union[str, Dict[str, List[int]], Callable]]): The individual which will be evaluated.
        """
        try:
            score = self._eval(ind, self.X, self.Y)
        except ZeroDivisionError:
            score = 0
        ind["fitness"] = score

    def fit(self, X, Y, test_X=None, test_Y=None):
        """Fits the model to a given X and Y values. The fitting will be made according to the
        structured grammar evolution workflow.

        Args:
            X (df): the set of points to fit on
            Y (df): the groups for each point

        Returns:
            Dict: The history of the max, min and avg fitness of the population throughout the generations and the best individual.
        """
        total_time = time()
        self.X = X
        self.Y = Y

        self.initializePopulation()
        
        avg_fitness = []
        max_fitness = []
        min_fitness = []
        test_fitness = []
        better_than_prev_gen = []
        
        for it in range(self.generations):
            it_time = time()
            
            print("generation {}".format(it + 1))
            total_fit = 0
            min_fit = None
            max_fit = None
            max_test_fit = 0
            
            for i, d in enumerate(self.population):
                if d["fitness"] == None:
                    self.evaluate_individual(d)

                if min_fit is None or d["fitness"] < min_fit:
                    min_fit = d["fitness"]

                if max_fit is None or d["fitness"] > max_fit:
                    max_fit = d["fitness"]
                    self.best_indivitual = d
                    if not test_X is None:
                        max_test_fit = self(test_X, test_Y)

                total_fit += d["fitness"]
                log = "\ravg: {:.5f} - max: {:.5f} - min: {:.5f}".format(
                    total_fit/(i + 1), max_fit, min_fit)

                if not test_X is None:
                    log = log + " - test: {:.5f}".format(max_test_fit)

                print(log,  end="")
            print()
            
            max_fitness += [max_fit]
            min_fitness += [min_fit]
            avg_fitness += [total_fit / len(self.population)]
            
            self.population.sort(reverse=True, key=itemgetter("fitness"))
            
            self.best_indivitual = self.population[0]
            if not test_X is None:
                test_fitness += [self(test_X, test_Y)]
            
            if (it + 1) % self.checkpoint == 0:
                print(
                    f"Saving checkpoint at checkpoints/{self.checkpoint_prefix}checkpoint_{it//5}.json")
                with open(f"checkpoints/{self.checkpoint_prefix}checkpoint_{it//5}.json", "w") as f:
                    best = deepcopy(self.best_indivitual["genome"])
                    for k in best.keys():
                        best[k] = best[k].tolist()
                    json.dump({
                        "max_fitness": max_fitness,
                        "min_fitness": min_fitness,
                        "avg_fitness": avg_fitness,
                        "best_individual": {
                            "fitness": self.best_indivitual["fitness"],
                            "genome": best,
                        },
                    }, f)
            
            result = self.create_generation()
            
            print(
                f"repr: {result['reproduced']} - bet: {result['better']} - worse: {result['worse']} - cross: {result['crossed']} - mut: {result['mutated']}")
            better_than_prev_gen += [result['better']]
            print("elapsed time: {:0.2f}s".format(time() - it_time))

        for i, d in enumerate(self.population):
            if d["fitness"] == None:
                self.evaluate_individual(d)
        print("total elapsed time: {}".format(time()-total_time))
        return {
            "history": {
                "max_fitness": max_fitness,
                "min_fitness": min_fitness,
                "avg_fitness": avg_fitness,
                "test_fitness": test_fitness,
                "better_than_prev_gen": better_than_prev_gen,
            },
            "best_individual": self.best_indivitual,
        }
